# ARCHITECTURE.md

## 1. Основные принципы

Архитектура приложения основана на официальных рекомендациях Google и следует принципу **Разделения ответственности (Separation of Concerns)**. Это многослойная архитектура (Layered Architecture), реализующая паттерн **MVVM (Model-View-ViewModel)**.

Такой подход обеспечивает высокую модульность, упрощает тестирование и дальнейшее сопровождение кода. Каждый слой имеет четко определенную зону ответственности и минимально зависит от других слоев.

## 2. Структура слоев

Приложение состоит из двух основных логических слоев: **UI Layer** и **Data Layer**.

### 2.1. UI Layer (Слой интерфейса)

Отвечает за отображение данных на экране и обработку взаимодействий с пользователем.

*   **Components:**
    *   **Views (Composable functions):** Экраны, созданные с помощью Jetpack Compose. Являются "пассивными" и не содержат логики, кроме отображения состояния. Они подписываются на изменения состояния в `ViewModel` и передают ей события от пользователя (клики, жесты).
    *   **ViewModel:** Является владельцем и поставщиком состояния для UI. Обрабатывает события от UI, запрашивает данные у `Data Layer` и предоставляет `StateFlow` с готовым для отображения состоянием. `ViewModel` не имеет прямых ссылок на Composable-функции.

*   **Технологии:** Jetpack Compose, ViewModel, StateFlow, Coroutines, ExoPlayer.

### 2.2. Data Layer (Слой данных)

Отвечает за предоставление данных приложению, абстрагируя источники и логику их получения.

*   **Components:**
    *   **Repository (Репозиторий):** Единственная точка входа (Single Source of Truth) для `UI Layer`. Инкапсулирует логику работы с данными: определяет, когда запрашивать данные из сети, а когда из кеша, и управляет кешированием.
    *   **Data Sources (Источники данных):**
        *   **Remote Data Source (Сетевой источник):** Отвечает за выполнение всех сетевых операций: загрузка JSON-файла с контентом, загрузка и парсинг HTML-страниц `ok.ru`.
        *   **Local Data Source (Локальный источник):** Отвечает за кеширование данных на устройстве (чтение и запись JSON-файла во внутреннее хранилище).

*   **Технологии:** OkHttp, Jsoup, Moshi, Kotlin Coroutines, файловое API.

## 3. Диаграмма архитектуры

```
+------------------------------------------------+
|                   UI Layer                     |
|                                                |
|   +----------+      (Events)       +---------+  |
|   |  Screen  | ------------------> |         |  |
|   | (Compose)|      (State Updates)|         |  |
|   +----------+ <------------------ | ViewModel|  |
|                  (via StateFlow)   |         |  |
+--------------------|---------------------------+
                     | (Request Data)
                     |
+--------------------|---------------------------+
|                   Data Layer                   |
|                    |                           |
|                    v                           |
|             +------------+                     |
|             | Repository |                     |
|             +------------+                     |
|              /          \                      |
|             /            \                     |
|   +-------------------+  +------------------+  |
|   | Remote DataSource |  | Local DataSource |  |
|   | (OkHttp, Jsoup)   |  | (File Cache)     |  |
|   +-------------------+  +------------------+  |
+------------------------------------------------+
```

## 4. Потоки данных (Data Flows)

### 4.1. Получение списка контента

1.  **UI (Screen):** При старте экрана вызывается метод `ViewModel`.
2.  **ViewModel:** Запускает корутину и вызывает метод `getContent()` у `Repository`.
3.  **Repository:**
    a. Запускает две асинхронные задачи: одна для получения данных из `Local DataSource`, другая из `Remote DataSource`.
    b. Сначала возвращает `ViewModel` данные из `Local DataSource` (из кеша) для мгновенного отображения.
    c. После получения данных от `Remote DataSource`, сравнивает их с кешем.
    d. Если данные из сети новые, обновляет кеш через `Local DataSource` и возвращает свежие данные `ViewModel`.
4.  **ViewModel:** Получает данные, преобразует их в `UiState` (модель состояния для экрана) и обновляет `StateFlow`.
5.  **UI (Screen):** Будучи подписанным на `StateFlow`, автоматически получает новое состояние и перерисовывает список контента.

### 4.2. Получение ссылки на видео и воспроизведение

1.  **UI (Screen):** Пользователь нажимает на элемент списка. Событие передается в `ViewModel`.
2.  **ViewModel:** Вызывает метод `getVideoUrl(pageUrl)` у `Repository`.
3.  **Repository:** Делегирует вызов `Remote DataSource`.
4.  **Remote DataSource:**
    a. Выполняет HTTP-запрос к `pageUrl` с помощью `OkHttp`.
    b. Парсит полученный HTML с помощью `Jsoup` для извлечения прямой ссылки на видео.
    c. Возвращает ссылку `Repository`.
5.  **Repository:** Возвращает ссылку `ViewModel`.
6.  **ViewModel:** Обновляет `UiState`, добавляя в него полученную ссылку на видео.
7.  **UI (Screen):** Получает новое состояние и передает ссылку компоненту `ExoPlayer` для начала воспроизведения.

## 5. Ключевые технологические решения

*   **UI:** **Jetpack Compose** выбран для современного, декларативного и эффективного построения пользовательского интерфейса.
*   **Асинхронность:** **Kotlin Coroutines** и **Flow** используются во всех слоях для управления асинхронными операциями, обеспечивая отзывчивость UI и эффективную работу с сетью и диском.
*   **Внедрение зависимостей (Dependency Injection):** Будет использоваться ручное внедрение зависимостей (Manual DI) для простоты. Репозиторий будет создаваться и передаваться в `ViewModel` через фабрику.
*   **Состояние UI:** Управление состоянием в `ViewModel` будет осуществляться с помощью `StateFlow`, что обеспечивает предсказуемый и реактивный поток данных к UI.
